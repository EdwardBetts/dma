Desciption: Handle the "too many open files" error gracefully, retrying.
 I'll forward this patch when I catch up with the dma upstream.
Origin: other: http://svn.ringlet.net/svn/ringlet/mail/dma/
Forwarded: no
Author: Peter Pentchev <roam@ringlet.net>
Last-Update: 2009-09-01

--- a/dma.c
+++ b/dma.c
@@ -75,7 +75,7 @@
 static uid_t uid;
 static FILE *scanfile;
 static struct strlist seenmsg[16][16];
-
+static int morefiles;
 
 static int open_locked(const char *, int);
 
@@ -1391,15 +1391,21 @@
 	char *queueid;
 	char *queuefn;
 	off_t hdrlen;
-	int fd, locked, seenit;
+	int fd, locked, seenit, inmore;
 
 	LIST_INIT(&queue->queue);
 
+	inmore = morefiles;
+	if (morefiles) {
+		morefiles = 0;
+	} else {
+		seen_init();
+	}
+
 	spooldir = opendir(config->spooldir);
 	if (spooldir == NULL)
 		err(1, "reading queue");
 
-	seen_init();
 	while ((de = readdir(spooldir)) != NULL) {
 		sender = NULL;
 		queuef = NULL;
@@ -1415,12 +1421,22 @@
 		if (asprintf(&queuefn, "%s/%s", config->spooldir, de->d_name) < 0)
 			goto fail;
 		seenit = seen(de->d_name);
+		if (inmore && seenit) {
+			free(queuefn);
+			continue;
+		}
 		locked = 0;
 		fd = open_locked(queuefn, O_RDONLY|O_NONBLOCK);
 		if (fd < 0) {
 			/* Ignore locked files */
-			if (errno != EWOULDBLOCK)
+			if (errno != EWOULDBLOCK) {
+				if (errno == EMFILE || errno == ENFILE) {
+					morefiles = 1;
+					free(queuefn);
+					break;
+				}
 				goto skip_item;
+			}
 			if (!ignorelock || seenit)
 				continue;
 			fd = open(queuefn, O_RDONLY);
@@ -1505,12 +1521,15 @@
 static void
 run_queue(struct queue *queue)
 {
-	struct qitem *it;
+	struct qitem *it, *other;
 
 	if (LIST_EMPTY(&queue->queue))
 		return;
 
 	it = go_background(queue);
+	LIST_FOREACH(other, &queue->queue, next)
+		if (other->queuef != it->queuef && other->queuef != NULL)
+			close(fileno(other->queuef));
 	deliver(it);
 	/* NOTREACHED */
 }
@@ -1533,6 +1552,8 @@
 		       it->queueid,
 		       it->locked ? "*" : "",
 		       it->sender, it->addr);
+		if (it->queuef != NULL)
+			close(fileno(it->queuef));
 	}
 }
 
@@ -1663,16 +1684,21 @@
 		if (argc != 0)
 			errx(1, "sending mail and displaying queue is"
 				" mutually exclusive");
-		load_queue(&lqueue, 1);
-		show_queue(&lqueue);
+		do {
+			load_queue(&lqueue, 1);
+			if (!LIST_EMPTY(&lqueue.queue))
+				show_queue(&lqueue);
+		} while (morefiles);
 		return (0);
 	}
 
 	if (doqueue) {
 		if (argc != 0)
 			errx(1, "sending mail and queue pickup is mutually exclusive");
-		load_queue(&lqueue, 0);
-		run_queue(&lqueue);
+		do {
+			load_queue(&lqueue, 0);
+			run_queue(&lqueue);
+		} while (morefiles);
 		return (0);
 	}
 
